## Sample from the rails API

# This Users Controller handles registration, signing in
# and retrieving/saving user profile information
#
module V1
  class UsersController < ApplicationController
    before_filter :authorized, :except => [:sign_in, :sign_up, :new_facebook, :sign_up_step_two, :forgot_password, :ping, :reset_password, :recent_photos, :feedback]
    load_and_authorize_resource
    skip_load_and_authorize_resource :only => [:sign_in, :sign_up, :new_facebook, :sign_up_step_two, :forgot_password, :ping, :reset_password, :recent_photos, :feedback]

    # sign_in action
    #
    # * *Args*    :
    #   - +email+ -> User's Email
    #   - +password+ -> User's Password
    # * *Returns* :
    #   - User's attributes with the most recent api token
    # * *Raises* :
    #   - +Invalid Credentials+ -> if the given arguments don't match any user record
    #
    def sign_in
      @user = User.authenticate(params)
      if @user
        render :json => {:data => @user,
                         :admin => @user.role?('admin'),
                         :api_token => @user.most_recent_token,
                         :success => 'true',
                         :errors => []
        }, :status => 200
      else
        render :json => {:data => '',
                         :success => 'false',
                         :errors => ['Invalid credentials']
        }, :status => 200
      end
    end

    # sign_up action
    #
    # * *Args*    :
    #   - +user=>full_name+ -> User's Full Name
    #   - +user=>username+ -> User's Username
    #   - +user=>email+ -> User's Email
    #   - +user=>password+ -> User's Password
    # * *Returns* :
    #   - User's attributes with the most recent api token
    # * *Raises* :
    #   - +Errors+ -> if the user record is unable to save
    #
    def sign_up
      @user = User.new(params[:user])
      @user.registered = 1
      @user.enable_geolocation = 1;
      if @user.save
        @user.generate_api_token
        render :json => {:data => @user,
                         :api_token => @user.most_recent_token,
                         :success => 'true',
                         :errors => []
        }, :status => 200
      else
        render :json => {:data => '',
                         :success => 'false',
                         :errors => @user.errors.full_messages
        }, :status => 200
      end
    end

    # sign_up_step_two action
    #   -2nd step if already registered with a social site
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    #   - +user=>full_name+ -> User's Full Name
    #   - +user=>username+ -> User's Username
    #   - +user=>email+ -> User's Email
    #   - +user=>password+ -> User's Password
    # * *Returns* :
    #   - User's attributes with the most recent api token
    # * *Raises* :
    #   - +Errors+ -> if the user record is unable to save
    #   - +Invalid Token+ -> if the user api token is missing, or not in our records
    #
    def sign_up_step_two
      api_token =  UserApiToken.find_by_token(params[:api_token])

      if api_token
        user = api_token.user
        if user.update_attributes(params[:user])
          render :json => {:data => user,
                           :api_token => user.most_recent_token,
                           :success => 'true',
                           :errors => []
          }, :status => 200
          user.registered = 1
          user.save()
        else
          render :json => {:data => '',
                           :success => 'false',
                           :errors => user.errors.full_messages
          }, :status => 200
        end

      else
        render :json => {:data => '',
                         :success => 'false',
                         :errors => ['invalid token']
        }, :status => 200
      end
    end

    # forgot_password action
    #
    # * *Args*    :
    #   - +user=>email+ -> User's Email
    # * *Returns* :
    #   - A notice for the user to check their email
    # * *Raises* :
    #   - +Invalid email+ -> if the user email is missing, or not in our records
    #
    def forgot_password
      @user = User.find_by_email(params[:user][:email])
      if @user
        if @user.update_attribute('forgot_password_token', Digest::MD5.hexdigest(@user.email + @user.id.to_s + Time.now.strftime("%Y-%m-%d %H:%M:%S")))
          UserMailer.forgot_password(@user.email, @user.forgot_password_token, CLI_URL['cli_url']).deliver
            render :json => {:data => '',
                           :success => 'true',
                           :errors => ['Check your email to finish reseting your password.']
                           }, :status => 200
        end
      else
        render :json => {:data => '',
                         :success => 'false',
                         :errors => ['invalid email']
        }, :status => 200  
      end 
    end

    # ping action
    #   -simple ping to verify user is in our system
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    # * *Returns* :
    #   - User's attributes
    # * *Raises* :
    #   - +Invalid Token+ -> if the user api token is missing, or not in our records
    #
    def ping
       api_token =  UserApiToken.find_by_token(params[:api_token])
       if api_token
         user = api_token.user
         render :json => {:data => user,
                         :success => 'true',
                         :errors => ['pong']
                         }, :status => 200
       else 
         render :json => {:data => '',
                           :success => 'false',
                           :errors => ['invalid']
         }, :status => 200
       end 
    end

    # profile action
    #   -to retrieve other user's profile and acts
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    #   - +user_id+ -> Other User's ID
    # * *Returns* :
    #   - Other User's attributes and acts with the your most recent api token
    #
    def profile
      api_token =  UserApiToken.find_by_token(params[:api_token])
      user = User.find(params[:user_id])
      if api_token and user and api_token.user
          user.clean()
          render :json => {:data => user,
                           :acts => user.acts,
                           :photos => ActPhoto.find(:all, :limit => 6, :order => 'created_at DESC', :conditions => ["user_id = #{user.id} and act_id is not NULL"]),
                           :api_token => api_token.user.most_recent_token,
                           :success => 'true',
                           :errors => []
          }, :status => 200
      end
    end

    # profile_info action
    #   -to retrieve your attributes and settings
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    # * *Returns* :
    #   - User's attributes with the most recent api token
    #
    def profile_info
      api_token =  UserApiToken.find_by_token(params[:api_token])
      user = api_token.user
      data = []
      follows = []
      notifications = Notification.find(:all, :conditions => {:user_id => user.id}, :order => "created_at DESC", :limit => 4)
      user.following_users.each do |theuser|
        theuser.clean()
        follows << theuser.attributes
      end
      if api_token and user
          render :json => {:data => user,
                           :notifications => notifications,
                           :new_notifications => Notification.count(:conditions => {:user_id => user.id, :read => false}),
                           :following => follows,
                           :api_token => user.most_recent_token,
                           :success => 'true',
                           :errors => []
          }, :status => 200
      end
    end

    # save_profile_info action
    #   -to save your settings and attributes
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    #   - +user=>*+ -> Any User Attribute you would like to update
    # * *Returns* :
    #   - User's attributes with the most recent api token
    # * *Raises* :
    #   - +Errors+ -> if the user record is unable to update
    #
    def save_profile_info
      api_token =  UserApiToken.find_by_token(params[:api_token])
      user = api_token.user
      if api_token and user
        if params[:user][:city] && params[:user][:state]
          user.lat = nil
          user.lon = nil
        end
        if user.update_attributes(params[:user])
          UserMailer.changed_password(user.email).deliver if !params[:user][:password].blank?
           render :json => {:data => user,
                             :api_token => user.most_recent_token,
                             :success => 'true',
                             :errors => []
            }, :status => 200
        else
           render :json => {:data => '',
                               :success => 'false',
                               :errors => user.errors.full_messages
            }, :status => 200
        end
      end
    end
    
      # change_password action
      #   -to change a users password
      #
      # * *Args*    :
      #   - +api_token+ -> User's Api Token
      #    - +original_password+ -> User's Original Password
      #    - +new_password+ -> User's New Password
      # * *Returns* :
      #   - User's attributes with the most recent api token
      # * *Raises* :
      #   - +Errors+ -> if the original password does not match
      #
    def change_password
      api_token =  UserApiToken.find_by_token(params[:api_token])
      user = api_token.user
      if user
        if user.password_hash == BCrypt::Engine.hash_secret(params[:original_password], user.password_salt)
          user.password = params[:new_password];
        
          if user.save
                  render :json => {:data => user,
                                 :api_token => user.most_recent_token,
                                 :success => 'true',
                                 :errors => []
                }, :status => 200
          end  
        
        else
           render :json => {:data => '',
                             :success => 'false',
                             :errors => ['Original password does not match']
           }, :status => 200
        end
      end
       
    end
    
      # reset_password action
      #   -to reset a users password with a forgot password token
      #
      # * *Args*    :
      #    - +token+ -> User's Forgot Password Token
      #    - +new_password+ -> User's New Password
      # * *Returns* :
      #   - User's attributes with the most recent api token
      #
    def reset_password
      user = User.find_by_forgot_password_token(params[:token])
      if user
        user.password = params[:new_password];
        if user.save
                render :json => {:data => user,
                               :api_token => user.most_recent_token,
                               :success => 'true',
                               :errors => []
              }, :status => 200
        end
      end
    end
    
    # notifications action
    #   -returns an array of notifications, limiting 50, for the given user.
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    # * *Returns* :
    #   - array of notification hashes(marking them read after they are accessed for the first time)
    #
    
    def notifications
      api_token =  UserApiToken.find_by_token(params[:api_token])
      user = api_token.user
      data = []
      notifications = Notification.paginate(:conditions => {:user_id => user.id}, :order => "created_at DESC", :page=> params[:page], :per_page => 10)
      notifications.each do |notif|
        notifier = notif.notifier
        notifier.clean()
        data << notif.attributes.merge({:notifier => notifier})
        notif.read = true
        notif.save
      end
      if api_token and user
          render :json => {:data => data,
                           :current_page => notifications.current_page,
                           :per_page => notifications.per_page,
                           :total_entries => notifications.total_entries,
                           :api_token => user.most_recent_token,
                           :success => 'true',
                           :errors => []
          }, :status => 200
      end
    end
    
    # recent_photos action
    #   -returns an array of the most recent act photos, limiting 6, for the app homepage.
    #
    # * *Returns* :
    #   - array of the most recent act photos, limiting 6
    #
    
    def recent_photos
      render :json => {
        :data => ActPhoto.find(:all, :limit => 6, :order => 'created_at DESC', :conditions => ["act_id is not NULL"])
      }, :status => 200
    end
    
    # feedback action
    #   -mails any feedback given through the site.
    #
    
    def feedback
      Feedback.create(params[:feedback])
      UserMailer.feedback(params[:feedback]).deliver
      render :json => 1
    end
    
    # get_feedback action
    #   -returns all feedback to an admin user.
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    # * *Returns* :
    #   - array of feedback hashes
    #
    
    def get_feedback
      @feedback = Feedback.paginate(:order => 'created_at DESC', :page => params[:page], :per_page => 10)
      if current_user.role?('admin')
        render :json => {:data => @feedback,
                         :current_page => @feedback.current_page,
                         :per_page => @feedback.per_page,
                         :total_entries => @feedback.total_entries,
                         :api_token => current_user.most_recent_token,
                         :success => 'true',
                         :errors => []
        }, :status => 200
      else
        render :json => {:data => [],
                         :success => 'false',
                         :errors => ['Unauthorized']
        }, :status => 200
      end
    end
    
    # follow_user action
    #   -creates a connection between two users.
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    #   - +user_id+ -> Followed User's ID
    # * *Returns* :
    #   - array of current user's follows(users)
    #
    
    def follow_user
      UsersConnection.create(:parent_id => params[:user_id], :child_id => current_user.id)
      follows = []
      current_user.following_users.each do |theuser|
        theuser.clean()
        follows << theuser.attributes
      end
      render :json => {:data => follows,
                       :api_token => current_user.most_recent_token,
                       :success => 'true',
                       :errors => []
      }, :status => 200
    end
    
    # unfollow_user action
    #   -deletes connection between two users.
    #
    # * *Args*    :
    #   - +api_token+ -> User's Api Token
    #   - +user_id+ -> Followed User's ID
    # * *Returns* :
    #   - array of current user's follows(users)
    #
    
    def unfollow_user
      UsersConnection.where(:parent_id => params[:user_id].to_i, :child_id => current_user.id).each{|uc| uc.destroy }
      follows = []
      current_user.following_users.each do |theuser|
        theuser.clean()
        follows << theuser.attributes
      end
      render :json => {:data => follows,
                       :api_token => current_user.most_recent_token,
                       :success => 'true',
                       :errors => []
      }, :status => 200
    end
    
    # get_abusive action
    #   -returns an array of users with acts flagged abusive by other users.
    #
    # * *Args*    :
    #   - +api_token+ -> Admin's Api Token
    #   - +page+ -> The current page number
    # * *Returns* :
    #   - array of abusive user hashes or empty array as data
    #
    
    def get_abusive
      @users = User.paginate(:select => "users.*, SUM(acts.abuse_count) abuse_count",
                         :joins => :acts,
                         :conditions => ["acts.abuse_count > 0 and users.active = 1"],
                         :limit => 20,
                         :page => params[:page],
                         :per_page => 20,
                         :group => "users.id",
                         :order => "abuse_count DESC")
      render :json => {:data => @users,
                             :current_page => @users.current_page,
                             :per_page => @users.per_page,
                             :total_entries => @users.total_entries,
                             :success => 'true',
                             :errors => []
      }, :status => 200
    end
    
    # deactivate_user action
    #   -deactivates an abusive user (Admin).
    #
    # * *Args*    :
    #   - +api_token+ -> Admin's Api Token
    #   - +user_id+ -> Abusive User's ID
    # * *Returns* :
    #   - success
    #
    
    def deactivate_user
      @user = User.find(params[:user_id])
      @user.update_attribute('active', false);
      render :json => {:data => @user,
                             :success => 'true',
                             :errors => []
      }, :status => 200
    end
    
  end
end

## samples from the web client backbone.js structure - router

Give4.Routers.Kindness = Support.SwappingRouter.extend({
	
    initialize: function(options) {
        this.el = $('#page_container');
    },
    
    routes: {
       "kindness/all_acts"				: "all_acts",
       "kindness/popular_acts"		    : "popular_acts",
       "kindness/local_acts"			: "local_acts",
       "kindness/following"				: "following_acts",
       "search/:query"					: "search_acts",
       "kindness/act/:id"				: "act_page",
       "my_inspiration_queue"			: "my_queue",
       "kindness/map"					: "map",
	   "loadAct/:id"					: "loadAct"
    },

    all_acts: function() {
        app_loading_toggle('Loading Acts of Kindness');
        Give4.all_acts.fetchAll();
        pullacts = setInterval(function(){
            if( !Give4.PullingQueue && !Give4.PullingActs && !Give4.UserInfo['pulling'] ){
                clearInterval(pullacts);
                var view = new Give4.Views.AllActs();
                $('#page_container').html(view.render().el);
                app_loading_toggle();
                if(Give4.paginationData){
                    setContinuousStream(Give4.paginationData, 'all_acts');
                }
            }
        }, 200);
    },

    popular_acts: function() {
        app_loading_toggle('Loading Acts of Kindness');
        Give4.popular_acts.fetchPopular();
        pullacts = setInterval(function(){
            if( !Give4.PullingQueue && !Give4.PullingActs && !Give4.UserInfo['pulling'] ){
                clearInterval(pullacts);
                var view = new Give4.Views.PopularActs();
                $('#page_container').html(view.render().el);
                app_loading_toggle();
                if(Give4.paginationData){
                    setContinuousStream(Give4.paginationData, 'popular_acts');
                }
            }
        }, 200);
    },

    local_acts: function() {
        app_loading_toggle('Loading Acts of Kindness');
        Give4.local_acts.fetchLocal();
        pullacts = setInterval(function(){
            if( !Give4.PullingQueue && !Give4.PullingActs && !Give4.UserInfo['pulling'] ){
                clearInterval(pullacts);
                var view = new Give4.Views.LocalActs();
                $('#page_container').html(view.render().el);
                app_loading_toggle();
                if(Give4.paginationData){
                    setContinuousStream(Give4.paginationData, 'local_activity');
                }
            }
        }, 200);
    },

    following_acts: function() {
        app_loading_toggle('Loading Acts of Kindness');
        Give4.following_acts.fetchFollowing();
        pullacts = setInterval(function(){
            if( !Give4.PullingQueue && !Give4.PullingActs && !Give4.UserInfo['pulling'] ){
                clearInterval(pullacts);
                var view = new Give4.Views.FollowingActs();
                $('#page_container').html(view.render().el);
                app_loading_toggle();
                if(Give4.paginationData){
                    setContinuousStream(Give4.paginationData, 'following_acts');
                }
            }
        }, 200);
    },

    search_acts: function(query) {
        app_loading_toggle('Loading Acts of Kindness');
        Give4.searched_acts.fetchSearch(query);
        pullacts = setInterval(function(){
            if( !Give4.PullingQueue && !Give4.PullingActs && !Give4.UserInfo['pulling'] ){
                clearInterval(pullacts);
                var view = new Give4.Views.SearchActs();
                $('#page_container').html(view.render(query).el);
                app_loading_toggle();
                if(Give4.paginationData){
                    setContinuousStream(Give4.paginationData, 'search?query='+query);
                }
            }
        }, 200);
    },
    
    act_page: function(id) {
        app_loading_toggle('Loading Act of Kindness');
        Give4.current_act.getAct(id);
        pullacts = setInterval(function(){
            if( !Give4.PullingQueue && !Give4.PullingActs && !Give4.UserInfo['pulling'] ){
                clearInterval(pullacts);
                var view = new Give4.Views.ActPage();
                $('#page_container').html(view.render(id).el);
            }
        }, 200);
    },
    
    my_queue: function() {
        app_loading_toggle('Loading Acts of Kindness');
        pullacts = setInterval(function(){
            if( !Give4.PullingQueue && !Give4.UserInfo['pulling'] ){
                clearInterval(pullacts);
                var view = new Give4.Views.QueuePage();
                view.render();
            }
        }, 200);
    },

	map: function() {
        app_loading_toggle('Loading Map of Kindness');
        pullacts = setInterval(function(){
            if( !Give4.PullingQueue && !Give4.UserInfo['pulling'] ){
                clearInterval(pullacts);
				var view = new Give4.Views.MapPage();
		        $('#page_container').html(view.render().el);
				$('.prev_act, .next_act').hide();
				app_loading_toggle();
            }
        }, 200);
	},
	
	loadAct: function(id){
		gotoAct(id);
		Backbone.history.navigate('kindness/map', {replace: true});
	}
   
});

## more samples of backbone.js views -- cross-browser compatible

Give4.Views.UserProfile = Support.CompositeView.extend({
    initialize: function() {
        self = this;
        _.bindAll(this, "render");
    },
    
    render: function (user_id) {
        this.getProfile(user_id);
    },

		getProfile: function (user_id){
			var other = this;
			if( navigator.appName == 'Microsoft Internet Explorer' || navigator.appName == 'Netscape' ){
				url = '/request';
				data = JSON.stringify({url: '/users/profile', type: 'POST', data: {api_token: getCookie('give4apitoken'), user_id: user_id}});
				cross_domain = false;
			}else{
				url = gon.global.api_host['api_url']+'/users/profile';
				data = JSON.stringify({api_token: getCookie('give4apitoken'), user_id: user_id});
				cross_domain = true;
			}
			$.ajax({
				url: url,
				type: 'POST',
				beforeSend: function (request){ setHeaders(request) },
				crossDomain: cross_domain,
				dataType: 'json',
				data: data,
				success: function(data){
					Give4.users.add(data.data);
					user = Give4.users.get(user_id);
					$('#page_container').html(JST['user/profile']({ user: user, nav: other.options.nav, subnav: other.options.subnav }));
					other.addUserActs(data.acts);
					if( getCookie('give4id') != user_id ){
						other.appendUserPhotos(data.photos);
					}
					app_loading_toggle();
				}
			});
		},
		
		addUserActs: function(acts){
			own = false;
			$.each(acts.reverse(), function(index, act){
				if( act['user']['id'] == getCookie('give4id') ){ own = true; }
				$('#user_acts').append(JST['kindness/act_row']({ models: act, own: own }));
			});
		},
		
		appendUserPhotos: function(photos){
			other = this;
			if(photos.length > 0){
				$('#user_pics').html(JST['user/recent_photos']({ photos: photos}));
				$('.act_photo').click(function(){
					other.go_to_act($(this).data('act-id'));
				});
			}
		},
		
		go_to_act: function(act_id){
			Backbone.history.navigate('kindness/act/'+act_id, {trigger: true});
		}

});

