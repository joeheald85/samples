## sample from the Recipes controller

class RecipesController < ApplicationController
  before_filter :authenticate_user!, :except => [:index, :show, :reviews]
  load_and_authorize_resource
  skip_load_and_authorize_resource :only => [:index, :reviews, :images]
  layout 'user'
  before_filter :check_facebook, :only => [:index, :show, :reviews, :my_recipes]

  has_scope :title, :only => [:index, :my_recipes]
  has_scope :created, :only => [:index]
  has_scope :saved, :only => [:my_recipes]
  has_scope :rating, :only => [:index, :my_recipes]
  has_scope :popular, :only => [:index]
  has_scope :author, :only => [:index, :my_recipes]
  has_scope :catgroup, :only => [:index]
  has_scope :cat, :only => [:index]
  
  add_breadcrumb "Recipes", :recipes_path
  
  # index page
  #   -paginated index of all the sites active recipes
  #
  # * *Args*    :
  #   - +page+ -> Current page (Used with pagination)
  #   - +catgroup+ -> Recipe Category group
  # * *Returns* :
  #   - recipes index page with @recipes assign
  #
  def index
    if !cookies[:request].blank? and !current_user.blank?
      redirect_to new_recipe_path
      return
    end
    @recipes = apply_scopes(Recipe).active.publicly_available.paginate(:page => params[:page], :per_page => 18)
    params[:catgroup].present? ? @featured_recipes = nil : @featured_recipes = Recipe.where(:featured => true).order('featured_sort_order ASC')
    render :layout => 'application'
  end
  
  # show page
  #   -page to view details and reviews of a recipe
  #
  # * *Args*    :
  #   - +id+ -> Recipe ID
  # * *Returns* :
  #   - recipe page
  # * *Raises* :
  #   - +Missing+ -> If the recipe is inactive
  #
  def show
    @recipe = Recipe.find(params[:id])
    if @recipe.removed_at != nil
      #missing 404 page
    else
      @facemash = @recipe.facemash(current_user.nil? ? false : current_user.id)
      @reviews_helpful = RecipeReview.helpful.where(:recipe_id => params[:id])
      if user_signed_in?
        @review = RecipeReview.where(:recipe_id => params[:id], :user_id => current_user.id).limit(1).first
      end
      @review ||= RecipeReview.new
      @recipe_picture = RecipePicture.new
      gon.recipe_id = @recipe.id
      render :layout => 'application'
    end
  end
  
  # reviews page
  #   -page to view all reviews left for a recipe
  #
  # * *Args*    :
  #   - +id+ -> Recipe ID
  #   - +sort_by+ -> Reviews sort order
  #   - +page+ -> Current page (used with pagination)
  # * *Returns* :
  #   - @reviews assign with a user's @review assign, if exists
  #
  def reviews
    @recipe = Recipe.find(params[:id])
    @facemash = @recipe.facemash(current_user.nil? ? false : current_user.id)
    case params[:sort_by]
    when 'newest'
      order = "id DESC"
    when 'oldest'
      order = "id ASC"
    when 'rated_high'
      order = "rating DESC, id DESC"
    when 'rated_low'
      order = "rating ASC, id DESC"
    when 'most_helpful'
      order = "helpful_score DESC, id DESC"
    else
      order = "id DESC"
    end
    @reviews = RecipeReview.unscoped.with_comment.paginate(:page => params[:page], :per_page => 10, 
                                              :conditions => ["user_id != ? and recipe_id = ?", current_user.id, @recipe.id], 
                                              :order => order)
    if user_signed_in?
      @review = RecipeReview.where(:recipe_id => params[:id], :user_id => current_user.id).limit(1).first
    end
    @review ||= RecipeReview.new
    render :layout => 'application'
  end
  
  # my_recipes action
  #   -page to view your recipes and recipes you've added to your collections
  #
  # * *Args*    :
  #   - +page+ -> Current page (used with pagination)
  # * *Returns* :
  #   - paginated list of my recipes
  #
  def my_recipes
    #includes recipes shared to the user
    @recipes = apply_scopes(current_user.recipes.where(
                                ["`recipes`.`id` NOT IN(SELECT id FROM recipes where `recipes`.`user_id` = #{current_user.id} AND `recipes`.`removed_at` IS NOT NULL)"]
                              )
                           ).paginate(:page => params[:page], :per_page => 10)
    render :layout => 'application'
  end
  
  # new page
  #   -page to add a new recipe
  #
  # * *Returns* :
  #   - new recipe form
  #
  def new
    @recipe = Recipe.new
    @recipe_picture = RecipePicture.new
    @requester = cookies[:request] if !cookies[:request].blank?
    cookies[:request] = {:value => '', :expires => 1.second.from_now}
    @recipe.permission_type = current_user.default_recipe_sharing
    gon.recipe_id = 0
  end
  
  # create action
  #   -to create a new recipe
  #
  # * *Args*    :
  #   - +recipe=>**+ -> Recipe attributes
  #   - +requester+ -> User ID who is requesting the recipe
  # * *Returns* :
  #   - redirects users to the edit page of the newly created recipe
  # * *Raises* :
  #   - +re-render+ -> renders the new page if the recipe fails to save
  #
  def create
    @recipe = Recipe.new(params[:recipe])
    @recipe.user_id = current_user.id
    if @recipe.save
      @recipe.manage_recipe_pictures
      @recipe.share_with_requester(params[:requester]) if !params[:requester].blank?
      redirect_to edit_recipe_path(@recipe), :notice => 'Recipe Saved Successfully'
    else
      @recipe_picture = RecipePicture.new
      @requester = params[:requester] if !params[:requester].blank?
      gon.recipe_id = 0
      render :action => 'new'
    end
  end
  
  # edit page
  #   -page to edit an existing recipe
  #
  # * *Args*    :
  #   - +id+ -> Recipe ID
  # * *Returns* :
  #   - edit form with gon variable, gon.recipe_id
  #
  def edit
    @recipe = Recipe.find(params[:id])
    @recipe_picture = RecipePicture.new
    gon.recipe_id = @recipe.id
  end
  
  # update action
  #   -to updte attributes of an existing recipe
  #
  # * *Args*    :
  #   - +id+ -> Recipe ID
  #   - +recipe=>**+ -> Recipe attributes
  # * *Returns* :
  #   - redirects users back to the edit page with a flash notice
  # * *Raises* :
  #   - +re-render+ -> renders the edit page with errors, if the update fails
  #
  def update
    @recipe = Recipe.find(params[:id])
    if @recipe.update_attributes(params[:recipe])
      @recipe.manage_recipe_pictures
      redirect_to edit_recipe_path(@recipe), :notice => 'Recipe Saved Successfully'
    else
      @recipe_picture = RecipePicture.new
      gon.recipe_id = @recipe.id
      render :action => 'edit'
    end
  end
  
  # destroy action
  #   -to mark an existing recipe inactive
  #
  # * *Args*    :
  #   - +id+ -> Recipe ID
  # * *Returns* :
  #   - redirects users to my recipe page
  #
  def destroy
    # Soft delete aka hide the recipe
    @recipe = Recipe.find(params[:id])
    @recipe.update_attributes({:removed_at => Time.now, :removed_by => current_user.id, :active => 0})
    
    # Remove the recipe from user saved recipes
    @user_saved_recipe = UserSavedRecipe.find_by_user_id_and_recipe_id(current_user.id, params[:id].to_i)
    @user_saved_recipe.destroy
    
    redirect_to recipes_my_recipes_path
  end
  
  # Start Image uploader stuffs
  
  # picture_upload action
  #   -to create a new RecipePicture for a recipe
  #
  # * *Args*    :
  #   - +recipe_picture=>picture+ -> Recipe picture file
  #   - +recipe_picture=>recipe_id+ -> Recipe ID
  # * *Returns* :
  #   - json response with the the picture object hash
  # * *Raises* :
  #   - +error+ -> appends a error key to the result hash
  #
  def picture_upload
    @upload = RecipePicture.new(params[:recipe_picture])
    @upload.user_id = current_user.id
      
    @result = []
    @result.push({
              "name" => @upload.picture_file_name,
              "size" => @upload.picture.size
             })

    if @upload.save
      @result[0][:url] = @upload.picture.url(:medium),
      @result[0][:thumbnail_url] = @upload.picture.url(:thumb),
      @result[0][:medium_url] = @upload.picture.url(:medium),
      @result[0][:delete_url] = '/recipes/delete_image/' + @upload.id.to_s
      @result[0][:delete_type] = 'GET'
      @result[0][:image_id] = 'images_'+@upload.id.to_s
    else
      @result[0][:error] = 'Error Uploading Image'
    end
    
    render :json =>  @result.to_json
    
  end
  
  # images action
  #   -to pull all existing images for a specific recipe
  #
  # * *Args*    :
  #   - +id+ -> Recipe ID
  # * *Returns* :
  #   - json response with array of picture objects
  #
  def images
    @recipe = Recipe.find(params[:id])
    result = []
    
    pics = RecipePicture.find(:all, :conditions => {:recipe_id => @recipe.id, :user_id => current_user.id}, :order => :sort_order)
    pics.each do |recipe_picture|
      result.push({ "name" => recipe_picture.picture_file_name,
       "size" => recipe_picture.picture.size,
       "url" => recipe_picture.picture.url(:medium),
       "thumbnail_url" => recipe_picture.picture.url(:thumb),
       "medium_url" => recipe_picture.picture.url(:medium),
       "delete_url" => '/recipes/delete_image/' + recipe_picture.id.to_s,
       "delete_type" => "GET",
       "image_id" => 'images_'+recipe_picture.id.to_s,
       }
      )
    end
    render :json =>  result.to_json
  end
  
  # image_sort action
  #   -to arrange recipe pictures in a specific order
  #
  # * *Args*    :
  #   - +images+ -> Array of RecipePicture IDs
  # * *Returns* :
  #   - json response with empty array as result
  #
  def image_sort
    @counter = 0
    params[:images].each do |image_id|
      RecipePicture.update(image_id, {:sort_order => @counter})
      @counter += 1
    end
    result = []
    respond_to do |format|
      format.js { render :json => result.to_json }
    end
  end
  
  # delete_image action
  #   -to delete a recipe picture
  #
  # * *Args*    :
  #   - +upload_id+ -> RecipePicture ID
  # * *Returns* :
  #   - json response with empty array
  #
  def delete_image
     result = []
     @recipe_picture = RecipePicture.find(params[:upload_id])
     @recipe_picture.destroy
     render :json =>  result.to_json
  end
  # End Image uploader stuffs
  
  # share page
  #   -to share a recipe with friends of a social network
  #
  # * *Args*    :
  #   - +id+ -> Recipe ID
  # * *Returns* :
  #   - page to share recipes
  #
  def share
    @id = params[:id]
    @graph = Koala::Facebook::GraphAPI.new(current_user.fb_access_token)
    @friends = @graph.fql_query('SELECT uid, name, pic_square FROM user WHERE is_app_user=1 AND uid IN (SELECT uid2 FROM friend WHERE uid1 = me())')
  end
  
  # share_to_fb_friends action
  #   -to share a recipe to selected friends
  #
  # * *Args*    :
  #   - +friends+ -> array of friends' Facebook IDs
  #   - +recipe_id+ -> Recipe ID
  # * *Returns* :
  #   - redirects users to the recipes index
  #
  def share_to_fb_friends
    params[:friends].each do |id|
     user = User.find_by_facebook_id(id)
     UserSavedRecipe.find_or_create_by_recipe_id_and_user_id(params[:recipe_id], user.id)
     UserMailer.share_recipe(request.host_with_port, user.email, current_user.username, params[:recipe_id]).deliver
    end
    redirect_to recipes_path
  end
  
  # request_recipe action
  #   -to request a recipe from one or more people by email
  #
  # * *Args*    :
  #   - +email+ -> email address or multiple email addresses separated by comma
  #   - +message+ -> Custom message to each recipient
  # * *Returns* :
  #   - json response of 1
  #
  def request_recipe
    emails = params[:email].split(',')
    emails.each do |email|
      UserMailer.request_recipe(request.host_with_port, email, current_user.id, params[:message]).deliver
      UserMailer.recipe_requested(email, current_user.id).deliver
    end
    render :json => 1
  end
  
  # search page
  #   -to search recipes by title or description
  #
  # * *Args*    :
  #   - +query+ -> Search term
  #   - +page+ -> Current page (used with pagination)
  # * *Returns* :
  #   - renders recipe index with search results
  #
  def search
      if params[:query].present?
          query = params[:query]
          results = Recipe.publicly_available.search(load: true, :page => (params[:page] || 1), :per_page => 10) do
              query do
                 boolean do
                     should   { string "title:#{query}" }
                     should   { string "description:#{query}" }
                 end
              end
            filter :terms, :permission_type => ['public']
            filter :terms, :active => ['1']      
            sort { by :created_at, 'desc' }
          end
        @recipes = results
      else
       @recipes = apply_scopes(Recipe).publicly_available.paginate(:page => params[:page], :per_page => 18)
      end
      render 'recipes/index', :layout => 'application'
  end
  

end

## sample of the User Model

class User < ActiveRecord::Base
  has_many :user_roles
  has_many :collections
  has_many :user_saved_recipes
  has_many :recipes, :through => :user_saved_recipes
  has_many :cookbooks
  has_many :cookbook_recipes
  has_many :roles, :through => :user_roles
  has_many :recipe_pictures
  has_many :orders
  has_many :order_items
  has_one :twitter_account, :dependent => :destroy
  has_many :shopping_carts
  has_attached_file :profile_picture, :styles => { :large => "170x170#", :medium => "138x138#", :thumb => "40x40#", :tiny => "20x20#" },
                                      :url => "/system/profile_pictures/:id/:style/:normalized_file_name.:extension",
                                      :path => ":rails_root/public/system/profile_pictures/:id/:style/:normalized_file_name.:extension"
    
  validates_presence_of      :username, :on => :update
  validates_acceptance_of    :terms_of_service, :on => :update
  validates_attachment_content_type :profile_picture, :content_type => /^image\/(?:jpeg|gif|png)$/
  
  devise :database_authenticatable, :registerable, :recoverable, :rememberable, :trackable, :validatable, :omniauthable, :email_regexp =>  /^([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$/i
  attr_accessible :email, :password, :password_confirmation, :remember_me, :username, :bio, :profile_picture, :fb_access_token, :terms_of_service, :default_recipe_sharing, :facebook_id, :never_set_password
  attr_accessor :remove_twitter
  attr_accessible :remove_twitter, :first_name, :last_name, :gender, :country
  before_save :remove_social
  API_LOGIN = AUTHORIZE_NET['api_login']
  API_KEY   = AUTHORIZE_NET['api_key']

  
  # find_for_facebook_oauth
  #   -to set the Facebook access token for a user, or create a new user if they dont exist
  #
  # * *Args*    :
  #   - +access_token+ -> Facebook access token
  #   - +signed_in_resource+ -> user object
  #   - +invite_token+ -> User's invite token
  # * *Returns* :
  #   - User object
  # * *Raises* :
  #   - +false+ -> returns false the user hasnt signed up yet, and has no invite token
  #
  def self.find_for_facebook_oauth(access_token, signed_in_resource=nil, invite_token)    
    data = access_token.extra.raw_info
    facebook_token = access_token.credentials.token
    if user = self.find_by_facebook_id(access_token.uid)
      user.update_attribute('fb_access_token', facebook_token)
      user
    else # Create a user with a stub password. 
      if invite_token.nil?
          return false
      end
      user = User.new(:email => data.email, :password => Devise.friendly_token[0,20], :fb_access_token => facebook_token, :facebook_id => access_token.uid, :never_set_password => 1)
      user.save(:validate => false)
      user.roles << Role.find_by_name('user')
      user.save(:validate => false)
      PendingRequest.where(:email => data.email).destroy_all
      @graph = Koala::Facebook::GraphAPI.new(user.fb_access_token)
      profile_image = @graph.get_picture("me", {:type => 'large'})
      user.update_attribute(:profile_picture, open(profile_image))
      user
    end
  end
  
  # new_with_session
  #   -to set a new User's email address based on their Facebook credentials
  #
  # * *Args*    :
  #   - +params+ -> parameters
  #   - +session+ -> devise session hash
  # 
  def self.new_with_session(params, session)
    super.tap do |user|
      if data = session["devise.facebook_data"] && session["devise.facebook_data"]["extra"]["raw_info"]
        user.email = data["email"]
      end
    end
  end
  
  # role?
  #   -to determine if a given User has a specific role
  #
  # * *Args*    :
  #   - +role+ -> name of the role
  # * *Returns* :
  #   - true if the user has the given role, false if not
  # 
  def role?(role)
    if self.roles.empty?
      return false
    end
    role = self.roles.find_by_name(role.to_s)
    if role.nil?
      return false
    else
      return true
    end
  end
  
  Paperclip.interpolates :normalized_file_name do |attachment, style|
    attachment.instance.normalized_file_name
  end

  def normalized_file_name
    Digest::MD5.hexdigest(self.profile_picture_file_name+self.id.to_s)
  end
  
  # facebook_auth_url
  #   -to construct and return the Facebook OAuth URL
  #
  # * *Args*    :
  #   - +callback_url+ -> callback url
  # * *Returns* :
  #   - Facebook OAuth URL
  #
  def self.facebook_auth_url(callback_url)
    oauth_authorize_url = "https://graph.facebook.com/oauth/authorize?client_id=#{Rails.configuration.fb_app_id}&redirect_uri=#{callback_url}&scope=offline_access,publish_stream,email,read_friendlists,publish_actions,user_photos,friends_photos&display=popup"
  end
  
  # validate_oauth_token
  #   -to validate a Facebook access token
  #
  # * *Args*    :
  #   - +oauth_verifier+ -> Facebook OAuth Verifier
  #   - +callback_url+ -> Facebook connect callback URL
  # * *Returns* :
  #   - true, if the OAuth response contains a valid access token
  # * *Raises* :
  #   - +false+ -> if the OAuth response does not contain a valid access token
  #
  def validate_oauth_token(oauth_verifier, callback_url = '')
    response = RestClient.get 'https://graph.facebook.com/oauth/access_token', :params => {
                   :client_id => Rails.configuration.fb_app_id,
                   :redirect_uri => callback_url.to_s,
                   :client_secret => Rails.configuration.fb_app_secret,
                   :code => oauth_verifier.to_s
                }
    pair = response.body.split("&")[0].split("=")
    if (pair[0] == "access_token")
      self.fb_access_token = pair[1]
      response = RestClient.get 'https://graph.facebook.com/me', :params => {:access_token => self.fb_access_token}
      self.facebook_id = JSON.parse(response.body)["id"]
      self.save!
      return true
    else 
      return false
    end
  end
  
  # remove_social
  #   -to remove an association between a user and a Twitter account
  #
  def remove_social
    if self.remove_twitter == '1'
      existing_twitter = TwitterAccount.find_by_user_id(self.id)
      if !existing_twitter.nil?
          existing_twitter.destroy
      end
    end
  end
  
  # app_friends
  #   -to retrieve a user's Facebook friends
  #
  def app_friends
    @friends = []
    if !self.fb_access_token.nil?
      @graph = Koala::Facebook::GraphAPI.new(self.fb_access_token)
      @friends = @graph.fql_query('SELECT uid, name, pic_square
                                FROM user
                                WHERE is_app_user = 1
                                AND uid IN (SELECT uid2 FROM friend WHERE uid1 = me())')
    end

    return @friends
  end
  
  # Used in CookBook when adding recipes in step 1
  def as_json(options = {})
    {
      :id => self.id,
      :username => self.username,
      :thumb_url => self.profile_picture.present? ? self.profile_picture.url(:thumb) : nil
    }
  end
  
  # check_valid_fb_token
  #   -to check the validity of a User's facebook token
  #
  # * *Returns* :
  #   - true if valid
  # * *Raises* :
  #   - +false+ -> if the access token is invalid
  #
  def check_valid_fb_token
    if !self.fb_access_token.nil?
      begin
        @graph = Koala::Facebook::API.new(self.fb_access_token)
        profile = @graph.get_object("me")
      rescue Koala::Facebook::APIError => exc
        if exc.fb_error_type = 'OAuthException'
          return false
        end
      end
    end
    return true
  end
  
  # checkout_carts
  #   -to pay for a User's existing shopping carts through Auth.net
  #
  # * *Args*    :
  #   - +data+ -> Payment data
  # * *Returns* :
  #   - the transaction ID from Auth.net
  # * *Raises* :
  #   - +false+ -> if the transaction fails
  #
  def checkout_carts(data)
    address = AuthorizeNet::Address.new( :first_name => data[:first_name], 
                                        :last_name => data[:last_name], 
                                        :city => data[:city], 
                                        :state => data[:state], 
                                        :zip => data[:zip], 
                                        :street_address => data[:address]
                                        )
    customer = AuthorizeNet::Customer.new(
       :address => address
    )
    months = Date::MONTHNAMES
    credit_card = AuthorizeNet::CreditCard.new(data[:card_no], ("%02d"%months.index(data[:month])).to_s+data[:year].last(2), :card_code => data[:cvv])
    
    # save auth payment info
    if data[:save_card] == 'true'
      transaction = AuthorizeNet::CIM::Transaction.new(User::API_LOGIN, User::API_KEY, :test => true)
      profile = AuthorizeNet::CIM::CustomerProfile.new(
         :email => self.email,
         :id => self.id
      )
      response = transaction.create_profile(profile)
      Rails.logger.info response.inspect
      self.auth_profile_id = response.profile_id if response.success?
      payment_profile = AuthorizeNet::CIM::PaymentProfile.new(
         :payment_method => credit_card,
         :billing_address => address
      )
      response = transaction.create_payment_profile(payment_profile, self.auth_profile_id)
      Rails.logger.info response.inspect
      self.auth_payment_profile_id = response.payment_profile_id
      self.save
    end
    
    if !Rails.env.production?
      transaction = AuthorizeNet::AIM::Transaction.new(User::API_LOGIN, User::API_KEY, :test => true)
    else
      #remove test option for live account
      transaction = AuthorizeNet::AIM::Transaction.new(User::API_LOGIN, User::API_KEY, :test => true)
    end
    
    transaction.set_customer(customer)
    #data[:total] = '1' if data[:card_no] == '6011000000000012'
    response = transaction.purchase(data[:total], credit_card)
    if response.success?
      return response.transaction_id
    else
      Rails.logger.info response.inspect
      return false
    end
  end
  
  # get_cart_qty_weight
  #   -to retrieve the weight and quantity of all cookbooks within a user's shopping cart
  #
  # * *Returns* :
  #   - an array containing the quanity and weight ([qty, weight])
  #
  def get_cart_qty_weight
    qty = 0
    weight = 0.0
    self.shopping_carts.each do |c|
      qty += c.quantity
      weight += ((c.cookbook.cookbook_format_binding.binding_name == 'hardcover' ? 1.1 : 0.8 ) * c.quantity)
    end
    return [qty, weight]
  end
  
  # get_shipping_cost
  #   -to get a shipping rate quote from UPS
  #
  # * *Args*    :
  #   - +qty+ -> Order cookbook quantity
  #   - +weight+ -> total Order weight
  #   - +zip+ -> zip code to send the order
  # * *Returns* :
  #   - the shipping cost as estimated by UPS
  # * *Raises* :
  #   - +error+ -> returns 0 as shipping rate, if the request fails
  #
  def get_shipping_cost(qty, weight, zip)
    data = "<?xml version=\"1.0\"?><AccessRequest xml:lang=\"en-US\"><AccessLicenseNumber>XXXX</AccessLicenseNumber><UserId>xxx</UserId><Password>xxxx</Password></AccessRequest>"
    data += "<?xml version=\"1.0\"?><RatingServiceSelectionRequest xml:lang=\"en-US\">"
    data += "<Request><TransactionReference><CustomerContext>Bare Bones Rate Request</CustomerContext><XpciVersion>1.0001</XpciVersion></TransactionReference><RequestAction>Rate</RequestAction><RequestOption>Rate</RequestOption></Request>"
    data += "<PickupType><Code>01</Code></PickupType>"
    data += "<Shipment><Shipper><Address><PostalCode>20774</PostalCode><CountryCode>US</CountryCode></Address><ShipperNumber>5E381V</ShipperNumber></Shipper>"
    data += "<ShipTo><Address><PostalCode>#{zip}</PostalCode><CountryCode>US</CountryCode><ResidentialAddressIndicator/></Address></ShipTo>"
    data += "<ShipFrom><Address><PostalCode>20774</PostalCode><CountryCode>US</CountryCode></Address></ShipFrom>"
    data += "<Service><Code>03</Code></Service><Package><PackagingType><Code>02</Code></PackagingType>"
    data += "<Dimensions><UnitOfMeasurement><Code>IN</Code></UnitOfMeasurement>"
    data += "<Length>9.5</Length><Width>13.5</Width>"
    data += "<Height>#{1.375 * qty}</Height></Dimensions>"
    data += "<PackageWeight><UnitOfMeasurement><Code>LBS</Code></UnitOfMeasurement>"
    data += "<Weight>#{weight}</Weight></PackageWeight>"
    data += "</Package></Shipment></RatingServiceSelectionRequest>";
    response = `curl -X POST -d '#{data}' https://www.ups.com/ups.app/xml/Rate`
    if !response.blank? and !response.split('<MonetaryValue>')[1].blank?
      shipping = response.split('<MonetaryValue>')[1].split('</MonetaryValue>')[0]
      return (shipping.blank? ? 0 : shipping)
    else
      return 0
    end
  end
  
  # create_order
  #   -to set a recipe as featured as an admin
  #
  # * *Args*    :
  #   - +data+ -> Order data
  #   - +transaction_id+ -> Auth.net Payment transaction ID
  # * *Returns* :
  #   - the newly created Order ID
  #
  def create_order(data, transaction_id)
    order = Order.create({
      :transaction_id => transaction_id,
      :user_id => self.id,
      :shipping_first_name => data[(data[:shipping].nil? ? :payment : :shipping)][:first_name],
      :shipping_last_name => data[(data[:shipping].nil? ? :payment : :shipping)][:last_name],
      :shipping_address1 => data[(data[:shipping].nil? ? :payment : :shipping)][:address],
      :shipping_address2 => data[(data[:shipping].nil? ? :payment : :shipping)][:address2],
      :shipping_city => data[(data[:shipping].nil? ? :payment : :shipping)][:city],
      :shipping_state => data[(data[:shipping].nil? ? :payment : :shipping)][:state],
      :shipping_zip => data[(data[:shipping].nil? ? :payment : :shipping)][:zip],
      :billing_first_name => data[:payment][:first_name],
      :billing_last_name => data[:payment][:last_name],
      :billing_address1 => data[:payment][:address],
      :billing_address2 => data[:payment][:address2],
      :billing_city => data[:payment][:city],
      :billing_state => data[:payment][:state],
      :billing_zip => data[:payment][:zip],
      :card_no => ("x"*(data[:payment][:card_no].length-4))+data[:payment][:card_no].last(4),
      :card_exp => data[:payment][:month]+' '+data[:payment][:year],
      :card_type => data[:payment][:type],
      :shipping => data[:payment][:shipping],
      :tax => data[:payment][:tax],
      :price => data[:payment][:total]
    })
    order_path = Rails.root.to_s+'/public/system/orders/'+order.id.to_s
    Dir.mkdir(Rails.root.to_s+'/public/system/orders/') unless File.exists?(Rails.root.to_s+'/public/system/orders/')
    Dir.mkdir(order_path) unless File.exists?(order_path)
    data[:cart_ids].each do |cart_id|
      cart = ShoppingCart.find(cart_id)
      order_item = OrderItem.create({:user_id => cart.user_id, :cookbook_id => cart.cookbook_id, :quantity => cart.quantity, :title => cart.cookbook.title,
                                      :price => cart.price, :order_id => order.id, :pdf_name => cart.pdf_name, :pages => cart.cookbook.pages, :binding_name => cart.cookbook.cookbook_format_binding.binding_name})
      cart.destroy
      cookbook_path = Rails.root.to_s+'/public/system/cookbooks/'+order_item.cookbook_id.to_s
      `cp -r #{cookbook_path} #{order_path}`
      `rm -rf #{cookbook_path}`
    end
    return order.id
  end
  
end